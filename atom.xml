<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://musicpop.github.io/atom.xml" rel="self"/>
  <link href="http://musicpop.github.io/"/>
  <updated>2015-11-03T11:29:32+08:00</updated>
  <id>http://musicpop.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux-learn]]></title>
    <link href="http://musicpop.github.io/blog/2015/08/20/linux-learn/"/>
    <updated>2015-08-20T16:45:44+08:00</updated>
    <id>http://musicpop.github.io/blog/2015/08/20/linux-learn</id>
    <content type="html"><![CDATA[<p>bash使用中创建变量，变量是区分大小写的</p>

<h2>grep 命令</h2>

<p>grep搜索包含特定模式的文本行，可以在一个或多个文本中搜索。
也可以在输入流中搜索。</p>

<h3>基本的语法是：</h3>

<pre><code>grep pattern filename(或者grep "pattern" filename)
this is the line containing pattern
</code></pre>

<p>grep后可以加一些常用的选项，包括:</p>

<ul>
<li>-c：只输出匹配行的计数。</li>
<li>-I：不区分大小写(只适用于单字符)。</li>
<li>-h：查询多文件时不显示文件名。</li>
<li>-l：查询多文件时只输出包含匹配字符的文件名。</li>
<li>-n：显示匹配行及行号。</li>
<li>-s：不显示不存在或无匹配文本的错误信息。</li>
<li>-v：显示不包含匹配文本的所有行。</li>
</ul>


<h3>grep 与grep -E（也就是egrep）的区别：</h3>

<p>例1，grep命令也可以使用正则表达式来做字符串的匹配，
但需要加转义字符。
为了查找多个字符，可以使用命令：</p>

<pre><code> [root@devops ~]# grep 'user1\|user2\|user3' /etc/passwd
user1:x:501:501::/home/user1:/bin/bash
user1add:x:503:503::/home/user1add:/bin/bash
user2:x:504:504::/home/user2:/bin/bash
user3:x:505:505::/home/user3:/bin/bash
</code></pre>

<p>例2，grep命令的扩展版本egrep，带有更复杂的正则表达式元字符，对于以上例子，如果使用egrep，那么可以省略转义字符，如下：</p>

<pre><code>[root@devops ~]# egrep 'user1|user2|user3' /etc/passwd
user1:x:501:501::/home/user1:/bin/bash
user2:x:504:504::/home/user2:/bin/bash
user3:x:505:505::/home/user3:/bin/bash
</code></pre>

<h3>grep还可以在多级目录中对文本进行递归搜索</h3>

<p><code>grep "text" . -R -n</code></p>

<h3>grep 搜索中指定(include)或排除(exclude)文件</h3>

<p>目录中递归搜索所有的.c和.cpp文件</p>

<p><code>grep "main()" . -r --include *.{c,cpp}</code></p>

<p>在搜索中排除所有的README文件</p>

<p><code>grep "main()" . -r --exclude "README"</code></p>

<p>如果要排除目录，使用&ndash;exclude-dir选项</p>

<h3>有时候，我们不打算查看匹配的字符串，而只是想知道是否能够成功匹配。</h3>

<p>可以使用grep的静默选项（-q）来实现，
如果命令运行成功会返回0，如果失败则返回非0值</p>

<h2>find命令</h2>

<p>工作原理：沿着文件层次结构向下遍历，匹配符合条件的文件。
执行相应的操作。例如，列出base_path目录下的所有文件和文件夹：</p>

<p><code>find base_path</code></p>

<p>再例如：</p>

<p><code>find . -print</code></p>

<p>-print指明打印匹配文件的文件名时，&#8217;\n&#8217;对输出的文件名进行分隔。
-print0指明使用&#8217;\0&#8217;作为匹配的文件名之间的分隔符，也就是不换行。</p>

<h3>根据文件名进行搜索</h3>

<p>使用-name选项，后跟文件名或者包含通配符的文件名</p>

<h3>根据路径名进行搜索</h3>

<p>使用-path选项，将文件路径作为一个整体进行匹配</p>

<h3>基于目录深度的搜索</h3>

<p>大多数情况下，我们只需要在当前目录下搜索，无需再继续向下搜索。
这时使用深度选项来限制。深度设置为1表示在当前目录下查找，以此类推。
使用-maxdepth指定最大深度，使用-mindepth指定最小深度。</p>

<p>例如：</p>

<p><code>find . -maxdepth 1 -name "f*"　-print</code></p>

<h3>根据文件类型进行搜索</h3>

<p><code>find . -type d -pring</code></p>

<p>其中：普通文件的类型为f
      符合链接的类型为l
      目录的类型为    d
      字符设备的类型为c
      块设备的类型为  b
      套接字的类型为  s
      FIFO的类型为    p</p>

<h3>根据文件时间进行搜索</h3>

<p>Linux文件系统中的文件都有三种时间戳：</p>

<ul>
<li>1 访问时间（）：用户最近一次访问文件的时间</li>
<li>2 修改时间（）：文件内容最后一次被修改的时间</li>
<li>3 变化时间（）：文件元数据（）最后一次改变的时间</li>
<li><p>例如：打印出访问时间超所7天的所有文件</p></li>
</ul>


<p><code>find . -type f -atime +7 -print</code></p>

<p>其中指定-atime选项时，单位是天，参数值带有-表示小于，+表示大于，不带有符合表示当天。</p>

<h3>根据文件大小的搜索</h3>

<p>使用-size选项：</p>

<p><code>find . -type f -size +2k</code></p>

<h3>删除匹配的文件</h3>

<p>-delete可以用来删除查找到的文件</p>

<p><code>find . -type f -name "*.swap" -delete</code></p>

<h3>基于文件权限和所有权进行匹配</h3>

<p>-perm 匹配特定的权限值</p>

<p><code>find -type f -name "*.java" ! -perm 644</code></p>

<p>上面的例子，找出没有设置好权限的文件-user 选项找出特定用户所拥有的文件</p>

<p><code>find . -type f -user peng -print</code></p>

<h3>find与-exec结合</h3>

<p>我们查找出来的内容，不只是看一下而已，还会有进一步的操作，这时候-exec的作用就体现出来了。-exec 后面只能接受单个命令，{}表示查找出的文件名。以<code>;</code>结束，为了考虑各个系统<code>;</code>会有不同的意义,所以在前面加反斜杠。例如：</p>

<p><code>find . -type f -name "*.txt" -exec printf "Text file: %s\n" {} \;</code></p>

<p>如果后面要接多个参数，可以把多个命令写到一个shell脚本中。例如：</p>

<p><code>-exec ./command.sh {} \;</code></p>

<h3>find排除目录及文件</h3>

<p>-prune 选项，就表示，不寻找字符串作为寻找文件或目录的范本样式。
例如：</p>

<pre><code>ls -l

total 4

drwxrwxr-x. 2 peng peng 4096 Oct 12 17:10 fold1

`-rw-rw-r--. 1 peng peng    0 Oct 12 16:34 t1.txt

`-rw-rw-r--. 1 peng peng    0 Oct 12 16:35 t2.txt

`-rw-rw-r--. 1 peng peng    0 Oct 12 17:10 test.git

[peng@localhost learn]$ find . -path "./fold1"
/fold1

[`peng@localhost learn]$ find . -path "./fold1" -prune`
./fold1`
</code></pre>

<p>find . -path &ldquo;./fold1&rdquo; 是基本的查询命令。-prone就像一个判断语句,当发现-prune前面的表达式math时，返回真。</p>

<p><code>[peng@localhost learn]$ find . -path "./fold1" -prune -o -print</code>
<code>.</code>
<code>./t1.txt</code>
<code>./t2.txt</code>
<code>./test.git</code></p>

<p>当使用-o选项，表示逻辑或。如果其前返回真，则不执行后面的-print</p>

<p>如果其前返回假，则会执行-print并输出不包含./fold1的目录。</p>

<p>注意：-a 应该是and的缩写，意思是逻辑运算符‘或’(&amp;&amp;); -o应该是or的缩写,意思是逻辑运算符‘与’(||), -not 表示非.
比较下面的代码：</p>

<p>默默地</p>

<p><code>[peng@localhost learn]$ find . -path "./fold1" -prune -a -print</code></p>

<p><code>./fold1</code></p>

<h2>xargs命令</h2>

<p>为什么要使用xargs命令呢？我们可以使用管道将一个命令的stdout
重定向到另一个命令。例如</p>

<p><code>cat foo.txt | grep "test"</code></p>

<p>但是有些命令只能使用命令的参数接受数据，而无法通过stdin接收数据流。
那么，我们就设法用管道提供那些只有命令行参数需要的数据。
xargs命令将标准输入数据转换成命令行参数。
基本的语法是：</p>

<p><code>command | xargs</code></p>

<h3>第一步把stdin接收的数据重新格式化</h3>

<h3>第二步将其作为参数提供给其他命令</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idea-14-show-column-number-shortcutkey]]></title>
    <link href="http://musicpop.github.io/blog/2015/08/18/idea-14-show-column-number-shortcutkey/"/>
    <updated>2015-08-18T08:17:17+08:00</updated>
    <id>http://musicpop.github.io/blog/2015/08/18/idea-14-show-column-number-shortcutkey</id>
    <content type="html"><![CDATA[<h1>如何在Idea14中显示行号</h1>

<p><img src="images/column-number.png" alt="显示行号" /></p>

<h1>Idea常用快捷键汇总</h1>

<h2>找文件找代码找引用相关</h2>

<ol>
<li>双击shift   在项目的所有目录查找</li>
<li>ctrl+f    当前文件查找特定内容</li>
<li>ctrl+shift+f  find in path</li>
<li>ctrl+n    查找类</li>
<li>ctrl+shift+n 查找文件</li>
<li>ctrl+e 最近的文件</li>
<li><p>alt+F7
可以帮你找到你的函数或者变量或者类的所有引用到的地方</p>

<h2>编辑相关</h2></li>
<li><p>shift+enter 另起一行</p></li>
<li><p>ctrl+r 当前文件替换特定内容</p></li>
<li><p>ctrl+shift+r 当前项目替换特定内容</p></li>
<li><p>shift+F6 可以重命名你的类、方法、变量等等，而且这个重命名甚至可以选择替换掉注释中的内容</p></li>
<li><p>ctrl+d 复制当前行到下一行</p></li>
<li><p>ctrl+x 剪切当前行</p></li>
<li><p>ctrl+c \ ctrl+v 大家都懂的</p></li>
<li><p>ctrl+z 撤销</p></li>
<li><p>ctrl+shift+z 取消撤销</p></li>
<li><p>ctrl+k 提交代码到SVN</p></li>
<li><p>ctrl+t 更新代码</p></li>
<li><p>alt+insert
在类中使用：可以自动生成构造器、getter/setter等等常用方法
  在项目目录上使用：可用于新建各种文件。</p></li>
<li>ctrl+alt+L
  自动格式化代码，我已经养成了写完代码就来一发的习惯。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven]]></title>
    <link href="http://musicpop.github.io/blog/2015/06/10/maven/"/>
    <updated>2015-06-10T08:32:11+08:00</updated>
    <id>http://musicpop.github.io/blog/2015/06/10/maven</id>
    <content type="html"><![CDATA[<p>Maven笔记：
一，  主要命令
a)  Mvn clean compile
b)  Mvn clean test
c)  Mvn clean package
d)  Mvn clean install
执行test前会执行compile，执行package前会执行test，执行install前会执行package
二，  安装时compiler can not be resolved
因为公司里使用代理上网，配置maven的conf\setting添加
<proxy>
      <id>optional</id>
      <active>true</active>
      <protocol>http</protocol>
      <host>proxy1.sg.*.com</host>
      <port>81</port>
      <nonProxyHosts>local.net|some.host.com</nonProxyHosts>
    </proxy></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring-boot]]></title>
    <link href="http://musicpop.github.io/blog/2015/06/08/spring-boot/"/>
    <updated>2015-06-08T12:00:38+08:00</updated>
    <id>http://musicpop.github.io/blog/2015/06/08/spring-boot</id>
    <content type="html"><![CDATA[<p>Spring Boot用来创建独立的Java应用程序，并接可以用java -jar命令运行，也可创建传统的WAR文件。由于Spring使用了大量的XML配置文件以及复杂的依赖管理，这一点饱受非议。而Spring Boot充分利用了JavaConfig的配置模式以及“约定优于配置”的理念，能够极大的简化基于Spring MVC的Web应用和REST服务的开发。 Spring Boot 简化了部署的过程，其内嵌了Tomcat和Jety。 使用gradle和maven构建 使用时只需将org.springframework.boot设置为父项目 *如果想生成War包，并部署到外部容器，
参考<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#build-tool-plugins-maven-packaging">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#build-tool-plugins-maven-packaging</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件系统架构读书笔记]]></title>
    <link href="http://musicpop.github.io/blog/2014/11/03/ruan-jian-xi-tong-jia-gou-du-shu-bi-ji/"/>
    <updated>2014-11-03T16:55:05+08:00</updated>
    <id>http://musicpop.github.io/blog/2014/11/03/ruan-jian-xi-tong-jia-gou-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<h2>软件架构概念</h2>

<h3>系统的架构是一系列基本概念或者系统在其环境变量中变现出来的属性，体现在它的元素、关系以及设计和发展的原则中。</h3>

<p>系统架构还涉及到利益相关者，包括软件使用者、开发者、提供支持、部署或者为其付钱的人。架构师的工作就是与大量不同的利益相关者，协同工作，满足他们的关注点，管理并激励他们，获得他们的意见。从而形成了另外的概念视点和视角。以后在详细介绍这两个概念。</p>

<h3>软件的元素和关系</h3>

<h4>任何一个系统都是由许多部分组成的，这些部分称为模块、组件、部件或者子系统。我们遵循ISO标准，使用大家不太熟悉但在语义上中立的术语元素，来表示组成系统的部分。系统结构分为静态结构和动态结构。</h4>

<h3>系统的基本属性</h3>

<h4>系统的基本属性表现为两种不同的方式：外部可见行（系统所做的工作）和质量属性（系统如何完成工作）。</h4>

<p>1）系统的外部可见行为定义了系统和环境之间的功能交互。
2）质量属性是系统外部可见性，非功能性的属性，例如性能、安全或者可伸缩性。</p>

<h3>设计和发展的原则</h3>

<h4>对于一个结构良好、可维护的系统来说，有一种情况显而易见，就是它的实现是一致的。在架构设计的情景中，我们对架构原则进行定义：对指引架构定义的看法、方法或者意图的基本声明。</h4>

<h3>架构元素：构建系统的基本组成部分。</h3>

<p>应拥有一下关键属性：
*  一系列清晰定义的责任
*  清晰定义的边界
*  清晰定义的接口，它会定义元素为其他架构元素所提供的服务。</p>

<h3>利益相关者：可能是个人、团队或者组织</h3>

<h4>关注和兴趣点</h4>

<p>当你开始创建架构的时候，会发现你处理的是发现的过程，而不是捕获的过程，换言之，在系统开发生命周期早期过程中，你的利益相关者很可能无法精确描述出他的需求是什么。</p>

<h4>质量三角形:成本、质量、时间</h4>

<p>架构师的职责就是要知道哪些属性对于那些人重要，并在必要的时候达成一种可接受的折中方案。</p>

<h4>利益相关者的重要性</h4>

<h3>架构描述</h3>

<p>是一系列产出物，它会以利益相关者能够理解的形式编写架构的文档，并说明架构如何满足他们的关注点，
“产出物”包括很多，不仅是架构模型，还有范围定义、约束和原则。
必须能够提供能够总结这个系统的整体概况，还必须分解为能够验证的、足够细的详细内容，并且所描述的系统能够基于此构建。</p>

<h4>所有利益相关者都需要理解与之相关的架构。</h4>

<h3>核心概念之间的关系（图示）</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据端口号查找进程]]></title>
    <link href="http://musicpop.github.io/blog/2014/09/17/gen-ju-duan-kou-hao-cha-zhao-jin-cheng/"/>
    <updated>2014-09-17T21:00:18+08:00</updated>
    <id>http://musicpop.github.io/blog/2014/09/17/gen-ju-duan-kou-hao-cha-zhao-jin-cheng</id>
    <content type="html"><![CDATA[<p> lsof -Pnl +M -i4 | grep 20880</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCC and Make]]></title>
    <link href="http://musicpop.github.io/blog/2014/09/17/gcc-and-make/"/>
    <updated>2014-09-17T16:10:27+08:00</updated>
    <id>http://musicpop.github.io/blog/2014/09/17/gcc-and-make</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;GCC 开始是Gun C Complier，后来由于加入各种语言支持，能够编译java,c++等。慢慢演变为Gun Complier Collection。这节的内容包括Gcc介绍，Makefile介绍，GDB应用,Eclipse集成环境。</p>

<h2>Gcc编译过程</h2>

<p>*预处理：gcc -E main.c -o main.i</p>

<p>*编译  ：gcc -S main.i -o main.s</p>

<p>*汇编  ：gcc -c main.s -o main.o</p>

<p>*链接  ：gcc main.o -o main</p>

<h2>调试</h2>

<p>*编译文件并加入调试信息 gcc -O crash.c -o crash</p>

<p>*使用gdb调试 gdb crash</p>

<p>*加入断点 b 3</p>

<p>*开始调试 run</p>

<p>next 执行一行源码但不进入函数内部</p>

<p>step 执行一行源码且进入函数内部</p>

<p>continue 继续执行</p>

<p>quit 终止</p>

<h2>GCC编译过程中需要的库依赖</h2>

<p>-头文件
    搜索的路径包括：C_INCLUDE_PATH  CPLUS_INCLUDE_PATH OBJ_INCLUDE_PATH</p>

<pre><code>通过-l选项添加搜索目录
</code></pre>

<p>-静态库</p>

<pre><code>通过-L选项添加搜索目录

使用环境变量LD_LIBRARY_PATH
</code></pre>

<p>-动态库</p>

<pre><code>a.把库拷贝到/usr/lib，/lib，/usr/local/lib目录下

b.添加库路径到LD_LIBRARY_PATH

c.修改/etc/ld.so.conf文件，把库文件所在的目录放在文件末尾，并执行ldconfig刷新
</code></pre>

<h2>如何生成动态库</h2>

<p>*gcc -c main.c xiangjia.c xiangjian.c   生成.o文件</p>

<p>*此时执行gcc main.o -o main会出错，提示没有定义xiangjia 和 xiangjian</p>

<p>*ar cr libmath56.a xiangjia.o xiangjian.o 此时生成.a文件</p>

<p>*gcc main.o -o main libmath56.a 这个时候运行成功，生成main文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一篇博客]]></title>
    <link href="http://musicpop.github.io/blog/2014/09/15/my-first-octopress-blog/"/>
    <updated>2014-09-15T16:35:52+08:00</updated>
    <id>http://musicpop.github.io/blog/2014/09/15/my-first-octopress-blog</id>
    <content type="html"><![CDATA[<h1>shell命令，kde，gnome</h1>

<pre><code>&gt;引用蔡老师的话，首先要做人，技术只是吃饭的本领。
</code></pre>

<p>*shell命令行显示</p>

<pre><code>'''[mysql@rh19 ~]$

[root@rh19 root]#'''
</code></pre>

<p>*shell通配符</p>

<pre><code>**

*.

*?
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Title]]></title>
    <link href="http://musicpop.github.io/blog/2014/09/13/title/"/>
    <updated>2014-09-13T02:38:39+08:00</updated>
    <id>http://musicpop.github.io/blog/2014/09/13/title</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
